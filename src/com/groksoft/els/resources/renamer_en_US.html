<html>
<head>
    <style>
        html, body {
            font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif;
        }

        div {
            margin-left: 10px;
            margin-right: 4px;
        }

        table {
            border-bottom: 1px solid;
            margin: 0 4px 4px;
            padding: 4px;
            width: 100%;
        }

        th {
            border-bottom: 1px solid ;
            text-align: left;
        }

        td {
            text-align: left;
        }

        ul {
            margin-left: 22px;
        }
    </style>
</head>
<body>
<h2>Renamer</h2>
This tool may be applied to:
<ul>
    <li>Directory</li>
    <li>File</li>
</ul>

<h3>Common Options</h3>
<ul>
    <li>Recursive, process any selected directories and subdirectories recursively.<br><br></li>
    <li>The combobox selects which portion of the filename to process.</li>
    <ul>
        <li>Name only, process only the left-side of the filename before the extension.</li>
        <li>Extension only, process only the right-side of the filename.</li>
        <li>Whole filename, process the entire filename.</li>
    </ul>
</ul>

<h3>Case change</h3>
<div>
    Change the case of the selected filename segment.
</div>
<div>
    <ul>
        <li>Select one of the four types of case change.</li>
    </ul>
</div>

<h3>Insert</h3>
<div>
    Insert the text at the position.
</div>
<div>
    <ul>
        <li>Position is the location to insert, disabled if At end is enabled.</li>
        <li>From end calculates the position from the end instead of beginning.</li>
        <li>At end inserts at the end.</li>
        <li>Overwrite will replace any existing characters at position.</li>
    </ul>
</div>

<h3>Numbering</h3>
<div>
    Insert an incrementing number at position.
</div>
<div>
    <ul>
        <li>Start is the beginning value.</li>
        <li>Zeros is the number of zeros (places).</li>
        <li>Position is the location to insert, disabled if At end is enabled.</li>
        <li>From end calculates the position from the end instead of beginning.</li>
        <li>At end inserts at the end.</li>
        <li>Overwrite will replace any existing characters at position.</li>
    </ul>
</div>

<h3>Remove</h3>
<div>
    Remove characters at position.
</div>
<div>
    <ul>
        <li>From is the location to begin removing characters.</li>
        <li>Length is the number of characters to remove.</li>
        <li>From end calculates the position from the end instead of beginning.</li>
    </ul>
</div>

<h3>Replace</h3>

<div>
    Replace the "find" string with the "replace" string.
</div>
    <ul>
        <li>When regular expression is disabled a simple text search is performed, optionally case-sensitive.</li>
        <li>When regular expression is enabled a search may be case-insensitive by using the (?i).</li>
    </ul>

<h3>Summary of regular-expression constructs</h3>

<div>

<table border="0" cellpadding="1" cellspacing="0" summary="Regular expression constructs, and what they match">
    <tr align="left">
        <th align="left">Construct</th>
        <th align="left">Matches</th>
    </tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2">Characters</th></tr>

    <tr><td valign="top" headers="construct characters"><i>x</i></td>
        <td headers="matches">The character <i>x</i></td></tr>
    <tr><td valign="top" headers="construct characters"><tt>\\</tt></td>
        <td headers="matches">The backslash character</td></tr>
    <tr><td valign="top" headers="construct characters"><tt>\0</tt><i>n</i></td>
        <td headers="matches">The character with octal value <tt>0</tt><i>n</i>
            (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr>
    <tr><td valign="top" headers="construct characters"><tt>\0</tt><i>nn</i></td>
        <td headers="matches">The character with octal value <tt>0</tt><i>nn</i>
            (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr>
    <tr><td valign="top" headers="construct characters"><tt>\0</tt><i>mnn</i></td>
        <td headers="matches">The character with octal value <tt>0</tt><i>mnn</i>
            (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>m</i>&nbsp;<tt>&lt;=</tt>&nbsp;3,
            0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr>
    <tr><td valign="top" headers="construct characters"><tt>\x</tt><i>hh</i></td>
        <td headers="matches">The character with hexadecimal&nbsp;value&nbsp;<tt>0x</tt><i>hh</i></td></tr>
    <tr><td valign="top" headers="construct characters"><tt>&#92;u</tt><i>hhhh</i></td>
        <td headers="matches">The character with hexadecimal&nbsp;value&nbsp;<tt>0x</tt><i>hhhh</i></td></tr>
    <tr><td valign="top" headers="construct characters"><tt>&#92;x</tt><i>{h...h}</i></td>
        <td headers="matches">The character with hexadecimal&nbsp;value&nbsp;<tt>0x</tt><i>h...h</i>
            (<code>Character.MIN_CODE_POINT</code>
            &nbsp;&lt;=&nbsp;<tt>0x</tt><i>h...h</i>&nbsp;&lt;=&nbsp;
            <code>Character.MAX_CODE_POINT</code>)</td></tr>
    <tr><td valign="top" headers="matches"><tt>\t</tt></td>
        <td headers="matches">The tab character (<tt>'&#92;u0009'</tt>)</td></tr>
    <tr><td valign="top" headers="construct characters"><tt>\n</tt></td>
        <td headers="matches">The newline (line feed) character (<tt>'&#92;u000A'</tt>)</td></tr>
    <tr><td valign="top" headers="construct characters"><tt>\r</tt></td>
        <td headers="matches">The carriage-return character (<tt>'&#92;u000D'</tt>)</td></tr>
    <tr><td valign="top" headers="construct characters"><tt>\f</tt></td>
        <td headers="matches">The form-feed character (<tt>'&#92;u000C'</tt>)</td></tr>
    <tr><td valign="top" headers="construct characters"><tt>\a</tt></td>
        <td headers="matches">The alert (bell) character (<tt>'&#92;u0007'</tt>)</td></tr>
    <tr><td valign="top" headers="construct characters"><tt>\e</tt></td>
        <td headers="matches">The escape character (<tt>'&#92;u001B'</tt>)</td></tr>
    <tr><td valign="top" headers="construct characters"><tt>\c</tt><i>x</i></td>
        <td headers="matches">The control character corresponding to <i>x</i></td></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2">Character classes</th></tr>
    <tr><td valign="top" headers="construct classes"><code>[abc]</code></td>
        <td headers="matches"><code>a</code>, <code>b</code>, or <code>c</code> (simple class)</td></tr>
    <tr><td valign="top" headers="construct classes"><code>[^abc]</code></td>
        <td headers="matches">Any character except <code>a</code>, <code>b</code>, or <code>c</code> (negation)</td></tr>
    <tr><td valign="top" headers="construct classes"><code>[a-zA-Z]</code></td>
        <td headers="matches"><code>a</code> through <code>z</code>
            or <code>A</code> through <code>Z</code>, inclusive (range)</td></tr>
    <tr><td valign="top" headers="construct classes"><code>[a-d[m-p]]</code></td>
        <td headers="matches"><code>a</code> through <code>d</code>,
            or <code>m</code> through <code>p</code>: <code>[a-dm-p]</code> (union)</td></tr>
    <tr><td valign="top" headers="construct classes"><code>[a-z&amp;&amp;[def]]</code></td>
        <td headers="matches"><code>d</code>, <code>e</code>, or <code>f</code> (intersection)</tr>
    <tr><td valign="top" headers="construct classes"><code>[a-z&amp;&amp;[^bc]]</code></td>
        <td headers="matches"><code>a</code> through <code>z</code>,
            except for <code>b</code> and <code>c</code>: <code>[ad-z]</code> (subtraction)</td></tr>
    <tr><td valign="top" headers="construct classes"><code>[a-z&amp;&amp;[^m-p]]</code></td>
        <td headers="matches"><code>a</code> through <code>z</code>,
            and not <code>m</code> through <code>p</code>: <code>[a-lq-z]</code>(subtraction)</td></tr>
    <tr><th>&nbsp;</th></tr>

    <tr align="left"><th colspan="2">Predefined character classes</th></tr>
    <tr><td valign="top" headers="construct predef"><tt>.</tt></td>
        <td headers="matches">Any character (may or may not match line terminators)</td></tr>
    <tr><td valign="top" headers="construct predef"><tt>\d</tt></td>
        <td headers="matches">A digit: <tt>[0-9]</tt></td></tr>
    <tr><td valign="top" headers="construct predef"><tt>\D</tt></td>
        <td headers="matches">A non-digit: <tt>[^0-9]</tt></td></tr>
    <tr><td valign="top" headers="construct predef"><tt>\h</tt></td>
        <td headers="matches">A horizontal whitespace character:
            <tt>[ \t\xA0&#92;u1680&#92;u180e&#92;u2000-&#92;u200a&#92;u202f&#92;u205f&#92;u3000]</tt></td></tr>
    <tr><td valign="top" headers="construct predef"><tt>\H</tt></td>
        <td headers="matches">A non-horizontal whitespace character: <tt>[^\h]</tt></td></tr>
    <tr><td valign="top" headers="construct predef"><tt>\s</tt></td>
        <td headers="matches">A whitespace character: <tt>[ \t\n\x0B\f\r]</tt></td></tr>
    <tr><td valign="top" headers="construct predef"><tt>\S</tt></td>
        <td headers="matches">A non-whitespace character: <tt>[^\s]</tt></td></tr>
    <tr><td valign="top" headers="construct predef"><tt>\v</tt></td>
        <td headers="matches">A vertical whitespace character: <tt>[\n\x0B\f\r\x85&#92;u2028&#92;u2029]</tt>
        </td></tr>
    <tr><td valign="top" headers="construct predef"><tt>\V</tt></td>
        <td headers="matches">A non-vertical whitespace character: <tt>[^\v]</tt></td></tr>
    <tr><td valign="top" headers="construct predef"><tt>\w</tt></td>
        <td headers="matches">A word character: <tt>[a-zA-Z_0-9]</tt></td></tr>
    <tr><td valign="top" headers="construct predef"><tt>\W</tt></td>
        <td headers="matches">A non-word character: <tt>[^\w]</tt></td></tr>
    <tr><th>&nbsp;</th></tr>

    <tr align="left"><th colspan="2"><b>POSIX character classes (US-ASCII only)</b></th></tr>
    <tr><td valign="top" headers="construct posix"><code>\p{Lower}</code></td>
        <td headers="matches">A lower-case alphabetic character: <code>[a-z]</code></td></tr>
    <tr><td valign="top" headers="construct posix"><code>\p{Upper}</code></td>
        <td headers="matches">An upper-case alphabetic character:<code>[A-Z]</code></td></tr>
    <tr><td valign="top" headers="construct posix"><code>\p{ASCII}</code></td>
        <td headers="matches">All ASCII:<code>[\x00-\x7F]</code></td></tr>
    <tr><td valign="top" headers="construct posix"><code>\p{Alpha}</code></td>
        <td headers="matches">An alphabetic character:<code>[\p{Lower}\p{Upper}]</code></td></tr>
    <tr><td valign="top" headers="construct posix"><code>\p{Digit}</code></td>
        <td headers="matches">A decimal digit: <code>[0-9]</code></td></tr>
    <tr><td valign="top" headers="construct posix"><code>\p{Alnum}</code></td>
        <td headers="matches">An alphanumeric character:<code>[\p{Alpha}\p{Digit}]</code></td></tr>
    <tr><td valign="top" headers="construct posix"><code>\p{Punct}</code></td>
        <td headers="matches">Punctuation: One of <code>!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~</code></td></tr>
    <!-- <code>[\!"#\$%&amp;'\(\)\*\+,\-\./:;\&lt;=\&gt;\?@\[\\\]\^_`\{\|\}~]</code>
         <code>[\X21-\X2F\X31-\X40\X5B-\X60\X7B-\X7E]</code> -->
    <tr><td valign="top" headers="construct posix"><code>\p{Graph}</code></td>
        <td headers="matches">A visible character: <code>[\p{Alnum}\p{Punct}]</code></td></tr>
    <tr><td valign="top" headers="construct posix"><code>\p{Print}</code></td>
        <td headers="matches">A printable character: <code>[\p{Graph}\x20]</code></td></tr>
    <tr><td valign="top" headers="construct posix"><code>\p{Blank}</code></td>
        <td headers="matches">A space or a tab: <code>[ \t]</code></td></tr>
    <tr><td valign="top" headers="construct posix"><code>\p{Cntrl}</code></td>
        <td headers="matches">A control character: <code>[\x00-\x1F\x7F]</code></td></tr>
    <tr><td valign="top" headers="construct posix"><code>\p{XDigit}</code></td>
        <td headers="matches">A hexadecimal digit: <code>[0-9a-fA-F]</code></td></tr>
    <tr><td valign="top" headers="construct posix"><code>\p{Space}</code></td>
        <td headers="matches">A whitespace character: <code>[ \t\n\x0B\f\r]</code></td></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2">java.lang.Character classes (simple java character type)</th></tr>
    <tr><td valign="top"><tt>\p{javaLowerCase}</tt></td>
        <td>Equivalent to java.lang.Character.isLowerCase()</td></tr>
    <tr><td valign="top"><tt>\p{javaUpperCase}</tt></td>
        <td>Equivalent to java.lang.Character.isUpperCase()</td></tr>
    <tr><td valign="top"><tt>\p{javaWhitespace}</tt></td>
        <td>Equivalent to java.lang.Character.isWhitespace()</td></tr>
    <tr><td valign="top"><tt>\p{javaMirrored}</tt></td>
        <td>Equivalent to java.lang.Character.isMirrored()</td></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2">Classes for Unicode scripts, blocks, categories and binary properties</th></tr>
    <tr><td valign="top" headers="construct unicode"><code>\p{IsLatin}</code></td>
        <td headers="matches">A Latin&nbsp;script character (script)</td></tr>
    <tr><td valign="top" headers="construct unicode"><code>\p{InGreek}</code></td>
        <td headers="matches">A character in the Greek&nbsp;block (block)</td></tr>
    <tr><td valign="top" headers="construct unicode"><code>\p{Lu}</code></td>
        <td headers="matches">An uppercase letter (category)</td></tr>
    <tr><td valign="top" headers="construct unicode"><code>\p{IsAlphabetic}</code></td>
        <td headers="matches">An alphabetic character (binary property)</td></tr>
    <tr><td valign="top" headers="construct unicode"><code>\p{Sc}</code></td>
        <td headers="matches">A currency symbol</td></tr>
    <tr><td valign="top" headers="construct unicode"><code>\P{InGreek}</code></td>
        <td headers="matches">Any character except one in the Greek block (negation)</td></tr>
    <tr><td valign="top" headers="construct unicode"><code>[\p{L}&amp;&amp;[^\p{Lu}]]</code></td>
        <td headers="matches">Any letter except an uppercase letter (subtraction)</td></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2">Boundary matchers</th></tr>

    <tr><td valign="top" headers="construct bounds"><tt>^</tt></td>
        <td headers="matches">The beginning of a line</td></tr>
    <tr><td valign="top" headers="construct bounds"><tt>$</tt></td>
        <td headers="matches">The end of a line</td></tr>
    <tr><td valign="top" headers="construct bounds"><tt>\b</tt></td>
        <td headers="matches">A word boundary</td></tr>
    <tr><td valign="top" headers="construct bounds"><tt>\B</tt></td>
        <td headers="matches">A non-word boundary</td></tr>
    <tr><td valign="top" headers="construct bounds"><tt>\A</tt></td>
        <td headers="matches">The beginning of the input</td></tr>
    <tr><td valign="top" headers="construct bounds"><tt>\G</tt></td>
        <td headers="matches">The end of the previous match</td></tr>
    <tr><td valign="top" headers="construct bounds"><tt>\Z</tt></td>
        <td headers="matches">The end of the input but for the final
            terminator, if&nbsp;any</td></tr>
    <tr><td valign="top" headers="construct bounds"><tt>\z</tt></td>
        <td headers="matches">The end of the input</td></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2">Linebreak matcher</th></tr>
    <tr><td valign="top" headers="construct lineending"><tt>\R</tt></td>
        <td headers="matches">Any Unicode linebreak sequence, is equivalent to
            <tt>&#92;u000D&#92;u000A|[&#92;u000A&#92;u000B&#92;u000C&#92;u000D&#92;u0085&#92;u2028&#92;u2029]
            </tt></td></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2">Greedy quantifiers</th></tr>

    <tr><td valign="top" headers="construct greedy"><i>X</i><tt>?</tt></td>
        <td headers="matches"><i>X</i>, once or not at all</td></tr>
    <tr><td valign="top" headers="construct greedy"><i>X</i><tt>*</tt></td>
        <td headers="matches"><i>X</i>, zero or more times</td></tr>
    <tr><td valign="top" headers="construct greedy"><i>X</i><tt>+</tt></td>
        <td headers="matches"><i>X</i>, one or more times</td></tr>
    <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>}</tt></td>
        <td headers="matches"><i>X</i>, exactly <i>n</i> times</td></tr>
    <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>,}</tt></td>
        <td headers="matches"><i>X</i>, at least <i>n</i> times</td></tr>
    <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}</tt></td>
        <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2">Reluctant quantifiers</th></tr>

    <tr><td valign="top" headers="construct reluc"><i>X</i><tt>??</tt></td>
        <td headers="matches"><i>X</i>, once or not at all</td></tr>
    <tr><td valign="top" headers="construct reluc"><i>X</i><tt>*?</tt></td>
        <td headers="matches"><i>X</i>, zero or more times</td></tr>
    <tr><td valign="top" headers="construct reluc"><i>X</i><tt>+?</tt></td>
        <td headers="matches"><i>X</i>, one or more times</td></tr>
    <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>}?</tt></td>
        <td headers="matches"><i>X</i>, exactly <i>n</i> times</td></tr>
    <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>,}?</tt></td>
        <td headers="matches"><i>X</i>, at least <i>n</i> times</td></tr>
    <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}?</tt></td>
        <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2">Possessive quantifiers</th></tr>

    <tr><td valign="top" headers="construct poss"><i>X</i><tt>?+</tt></td>
        <td headers="matches"><i>X</i>, once or not at all</td></tr>
    <tr><td valign="top" headers="construct poss"><i>X</i><tt>*+</tt></td>
        <td headers="matches"><i>X</i>, zero or more times</td></tr>
    <tr><td valign="top" headers="construct poss"><i>X</i><tt>++</tt></td>
        <td headers="matches"><i>X</i>, one or more times</td></tr>
    <tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>}+</tt></td>
        <td headers="matches"><i>X</i>, exactly <i>n</i> times</td></tr>
    <tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>,}+</tt></td>
        <td headers="matches"><i>X</i>, at least <i>n</i> times</td></tr>
    <tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}+</tt></td>
        <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2">Logical operators</th></tr>

    <tr><td valign="top" headers="construct logical"><i>XY</i></td>
        <td headers="matches"><i>X</i> followed by <i>Y</i></td></tr>
    <tr><td valign="top" headers="construct logical"><i>X</i><tt>|</tt><i>Y</i></td>
        <td headers="matches">Either <i>X</i> or <i>Y</i></td></tr>
    <tr><td valign="top" headers="construct logical"><tt>(</tt><i>X</i><tt>)</tt></td>
        <td headers="matches">X, as a capturing group</td></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2">Back references</th></tr>

    <tr><td valign="bottom" headers="construct backref"><tt>\</tt><i>n</i></td>
        <td valign="bottom" headers="matches">Whatever the <i>n</i><sup>th</sup>
            capturing group matched</td></tr>

    <tr><td valign="bottom" headers="construct backref"><tt>\</tt><i>k</i>&lt;<i>name</i>&gt;</td>
        <td valign="bottom" headers="matches">Whatever the
            named-capturing group "name" matched</td></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2">Quotation</th></tr>

    <tr><td valign="top" headers="construct quot"><tt>\</tt></td>
        <td headers="matches">Nothing, but quotes the following character</td></tr>
    <tr><td valign="top" headers="construct quot"><tt>\Q</tt></td>
        <td headers="matches">Nothing, but quotes all characters until <tt>\E</tt></td></tr>
    <tr><td valign="top" headers="construct quot"><tt>\E</tt></td>
        <td headers="matches">Nothing, but ends quoting started by <tt>\Q</tt></td></tr>
    <!-- Metachars: !$()*+.<>?[\]^{|} -->

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2">Special constructs (named-capturing and non-capturing)</th></tr>

    <tr><td valign="top" headers="construct special"><tt>(?&lt;name&gt;</tt><i>X</i><tt>)</tt></td>
        <td headers="matches"><i>X</i>, as a named-capturing group</td></tr>
    <tr><td valign="top" headers="construct special"><tt>(?:</tt><i>X</i><tt>)</tt></td>
        <td headers="matches"><i>X</i>, as a non-capturing group</td></tr>
    <tr><td valign="top" headers="construct special"><tt>(?idmsuxU-idmsuxU)&nbsp;</tt></td>
        <td headers="matches">Nothing, but turns match flags i
            d m s
            u x U
            on - off</td></tr>
    <tr><td valign="top" headers="construct special"><tt>(?idmsux-idmsux:</tt><i>X</i><tt>)</tt>&nbsp;&nbsp;</td>
        <td headers="matches"><i>X</i>, as a non-capturing group with the
            given flags i d
            m s u</a >
            x on - off</td></tr>
    <tr><td valign="top" headers="construct special"><tt>(?=</tt><i>X</i><tt>)</tt></td>
        <td headers="matches"><i>X</i>, via zero-width positive lookahead</td></tr>
    <tr><td valign="top" headers="construct special"><tt>(?!</tt><i>X</i><tt>)</tt></td>
        <td headers="matches"><i>X</i>, via zero-width negative lookahead</td></tr>
    <tr><td valign="top" headers="construct special"><tt>(?&lt;=</tt><i>X</i><tt>)</tt></td>
        <td headers="matches"><i>X</i>, via zero-width positive lookbehind</td></tr>
    <tr><td valign="top" headers="construct special"><tt>(?&lt;!</tt><i>X</i><tt>)</tt></td>
        <td headers="matches"><i>X</i>, via zero-width negative lookbehind</td></tr>
    <tr><td valign="top" headers="construct special"><tt>(?&gt;</tt><i>X</i><tt>)</tt></td>
        <td headers="matches"><i>X</i>, as an independent, non-capturing group</td></tr>
</table>

<hr>

<h3>Backslashes, escapes, and quoting</h3>

<p> The backslash character (<tt>'\'</tt>) serves to introduce escaped
    constructs, as defined in the table above, as well as to quote characters
    that otherwise would be interpreted as unescaped constructs.  Thus the
    expression <tt>\\</tt> matches a single backslash and <tt>\{</tt> matches a
    left brace.

<p> It is an error to use a backslash prior to any alphabetic character that
    does not denote an escaped construct; these are reserved for future
    extensions to the regular-expression language.  A backslash may be used
    prior to a non-alphabetic character regardless of whether that character is
    part of an unescaped construct.

<p> Backslashes within string literals in Java source code are interpreted
    as required by
    <cite>The Java&trade; Language Specification</cite>
    as either Unicode escapes (section 3.3) or other character escapes (section 3.10.6)
    It is therefore necessary to double backslashes in string
    literals that represent regular expressions to protect them from
    interpretation by the Java bytecode compiler.  The string literal
    <tt>"&#92;b"</tt>, for example, matches a single backspace character when
    interpreted as a regular expression, while <tt>"&#92;&#92;b"</tt> matches a
    word boundary.  The string literal <tt>"&#92;(hello&#92;)"</tt> is illegal
    and leads to a compile-time error; in order to match the string
    <tt>(hello)</tt> the string literal <tt>"&#92;&#92;(hello&#92;&#92;)"</tt>
    must be used.

<h3>Character Classes</h3>
<p> Character classes may appear within other character classes, and
    may be composed by the union operator (implicit) and the intersection
    operator (<tt>&amp;&amp;</tt>).
    The union operator denotes a class that contains every character that is
    in at least one of its operand classes.  The intersection operator
    denotes a class that contains every character that is in both of its
    operand classes.

<p> The precedence of character-class operators is as follows, from
    highest to lowest:

<blockquote><table border="0" cellpadding="1" cellspacing="0" summary="Precedence of character class operators.">
    <tr><th>1&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <td>Literal escape&nbsp;&nbsp;&nbsp;&nbsp;</td>
        <td><tt>\x</tt></td></tr>
    <tr><th>2&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <td>Grouping</td>
        <td><tt>[...]</tt></td></tr>
    <tr><th>3&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <td>Range</td>
        <td><tt>a-z</tt></td></tr>
    <tr><th>4&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <td>Union</td>
        <td><tt>[a-e][i-u]</tt></td></tr>
    <tr><th>5&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <td>Intersection</td>
        <td><code>[a-z&amp;&amp;[aeiou]]</code></td></tr>
</table></blockquote>

<p> Note that a different set of metacharacters are in effect inside
    a character class than outside a character class. For instance, the
    regular expression <tt>.</tt> loses its special meaning inside a
    character class, while the expression <tt>-</tt> becomes a range
    forming metacharacter.

<h3>Line terminators</h3>
<p> A <i>line terminator</i> is a one- or two-character sequence that marks
    the end of a line of the input character sequence.  The following are
    recognized as line terminators:

<ul>
    <li> A newline (line feed) character&nbsp;(<tt>'\n'</tt>),

    <li> A carriage-return character followed immediately by a newline
        character&nbsp;(<tt>"\r\n"</tt>),

    <li> A standalone carriage-return character&nbsp;(<tt>'\r'</tt>),

    <li> A next-line character&nbsp;(<tt>'&#92;u0085'</tt>),

    <li> A line-separator character&nbsp;(<tt>'&#92;u2028'</tt>), or

    <li> A paragraph-separator character&nbsp;(<tt>'&#92;u2029</tt>).
</ul>

<p> If <code>UNIX_LINES</code> mode is activated, then the only line terminators
    recognized are newline characters.

<p> The regular expression <tt>.</tt> matches any character except a line
    terminator unless the <code>DOTALL</code> flag is specified.

<p> By default, the regular expressions <tt>^</tt> and <tt>$</tt> ignore
    line terminators and only match at the beginning and the end, respectively,
    of the entire input sequence. If <code>MULTILINE</code> mode is activated then
    <tt>^</tt> matches at the beginning of input and after any line terminator
    except at the end of input. When in <code>MULTILINE</code> mode <tt>$</tt>
    matches just before a line terminator or the end of the input sequence.

<h3>Groups and capturing</h3>

<h4>Group number</h4>
<p> Capturing groups are numbered by counting their opening parentheses from
    left to right.  In the expression <tt>((A)(B(C)))</tt>, for example, there
    are four such groups: </p>

<blockquote><table cellpadding=1 cellspacing=0 summary="Capturing group numberings">
    <tr><th>1&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <td><tt>((A)(B(C)))</tt></td></tr>
    <tr><th>2&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <td><tt>(A)</tt></td></tr>
    <tr><th>3&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <td><tt>(B(C))</tt></td></tr>
    <tr><th>4&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <td><tt>(C)</tt></td></tr>
</table></blockquote>

<p> Group zero always stands for the entire expression.

<p> Capturing groups are so named because, during a match, each subsequence
    of the input sequence that matches such a group is saved.  The captured
    subsequence may be used later in the expression, via a back reference, and
    may also be retrieved from the matcher once the match operation is complete.

<h4>Group name</h4>
<p>A capturing group can also be assigned a "name", a <tt>named-capturing group</tt>,
    and then be back-referenced later by the "name". Group names are composed of
    the following characters. The first character must be a <tt>letter</tt>.

<ul>
    <li> The uppercase letters <tt>'A'</tt> through <tt>'Z'</tt>
        (<tt>'&#92;u0041'</tt>&nbsp;through&nbsp;<tt>'&#92;u005a'</tt>),
    <li> The lowercase letters <tt>'a'</tt> through <tt>'z'</tt>
        (<tt>'&#92;u0061'</tt>&nbsp;through&nbsp;<tt>'&#92;u007a'</tt>),
    <li> The digits <tt>'0'</tt> through <tt>'9'</tt>
        (<tt>'&#92;u0030'</tt>&nbsp;through&nbsp;<tt>'&#92;u0039'</tt>),
</ul>

<p> A <tt>named-capturing group</tt> is still numbered as described in
    Group number.

<p> The captured input associated with a group is always the subsequence
    that the group most recently matched.  If a group is evaluated a second time
    because of quantification then its previously-captured value, if any, will
    be retained if the second evaluation fails.  Matching the string
    <tt>"aba"</tt> against the expression <tt>(a(b)?)+</tt>, for example, leaves
    group two set to <tt>"b"</tt>.  All captured input is discarded at the
    beginning of each match.

<p> Groups beginning with <tt>(?</tt> are either pure, <i>non-capturing</i> groups
    that do not capture text and do not count towards the group total, or
    <i>named-capturing</i> group.

<h3> Unicode support </h3>

<p> This class is in conformance with Level 1 of <i>Unicode Technical
    Standard #18: Unicode Regular Expression</i>, plus RL2.1
    Canonical Equivalents.
<p>
    <b>Unicode escape sequences</b> such as <tt>&#92;u2014</tt> in Java source code
    are processed as described in section 3.3 of
    <cite>The Java&trade; Language Specification</cite>.
    Such escape sequences are also implemented directly by the regular-expression
    parser so that Unicode escapes can be used in expressions that are read from
    files or from the keyboard.  Thus the strings <tt>"&#92;u2014"</tt> and
    <tt>"\\u2014"</tt>, while not equal, compile into the same pattern, which
    matches the character with hexadecimal value <tt>0x2014</tt>.
<p>
    A Unicode character can also be represented in a regular-expression by
    using its <b>Hex notation</b>(hexadecimal code point value) directly as described in construct
    <tt>&#92;x{...}</tt>, for example a supplementary character U+2011F
    can be specified as <tt>&#92;x{2011F}</tt>, instead of two consecutive
    Unicode escape sequences of the surrogate pair
    <tt>&#92;uD840</tt><tt>&#92;uDD1F</tt>.
<p>
    Unicode scripts, blocks, categories and binary properties are written with
    the <tt>\p</tt> and <tt>\P</tt> constructs as in Perl.
    <tt>\p{</tt><i>prop</i><tt>}</tt> matches if
    the input has the property <i>prop</i>, while <tt>\P{</tt><i>prop</i><tt>}</tt>
    does not match if the input has that property.
<p>
    Scripts, blocks, categories and binary properties can be used both inside
    and outside of a character class.
<p>
    <b>Scripts</b> are specified either with the prefix <code>Is</code>, as in
    <code>IsHiragana</code>, or by using  the <code>script</code> keyword (or its short
    form <code>sc</code>)as in <code>script=Hiragana</code> or <code>sc=Hiragana</code>.
<p>
    The script names supported by <code>Pattern</code> are the valid script names
    accepted and defined by
    <code>UnicodeScript.forName</code>.
<p>
    <b>Blocks</b> are specified with the prefix <code>In</code>, as in
    <code>InMongolian</code>, or by using the keyword <code>block</code> (or its short
    form <code>blk</code>) as in <code>block=Mongolian</code> or <code>blk=Mongolian</code>.
<p>
    The block names supported by <code>Pattern</code> are the valid block names
    accepted and defined by
    <code>UnicodeBlock.forName</code>.
<p>

    <b>Categories</b> may be specified with the optional prefix <code>Is</code>:
    Both <code>\p{L}</code> and <code>\p{IsL}</code> denote the category of Unicode
    letters. Same as scripts and blocks, categories can also be specified
    by using the keyword <code>general_category</code> (or its short form
    <code>gc</code>) as in <code>general_category=Lu</code> or <code>gc=Lu</code>.
<p>
    The supported categories are those of
    
        <i>The Unicode Standard</i> in the version specified by the
    <code>Character</code> class. The category names are those
    defined in the Standard, both normative and informative.
<p>
    <b>Binary properties</b> are specified with the prefix <code>Is</code>, as in
    <code>IsAlphabetic</code>. The supported binary properties by <code>Pattern</code>
    are
<ul>
    <li> Alphabetic
    <li> Ideographic
    <li> Letter
    <li> Lowercase
    <li> Uppercase
    <li> Titlecase
    <li> Punctuation
    <Li> Control
    <li> White_Space
    <li> Digit
    <li> Hex_Digit
    <li> Join_Control
    <li> Noncharacter_Code_Point
    <li> Assigned
</ul>
<p>
    The following <b>Predefined Character classes</b> and <b>POSIX character classes</b>
    are in conformance with the recommendation of <i>Annex C: Compatibility Properties</i>
    of <i>Unicode Regular Expression
</i>, when <code>UNICODE_CHARACTER_CLASS</code> flag is specified.

<table border="0" cellpadding="1" cellspacing="0"
       summary="predefined and posix character classes in Unicode mode">
    <tr align="left">
        <th align="left">Classes</th>
        <th align="left">Matches</th>
    </tr>
    <tr><td><tt>\p{Lower}</tt></td>
        <td>A lowercase character:<tt>\p{IsLowercase}</tt></td></tr>
    <tr><td><tt>\p{Upper}</tt></td>
        <td>An uppercase character:<tt>\p{IsUppercase}</tt></td></tr>
    <tr><td><tt>\p{ASCII}</tt></td>
        <td>All ASCII:<tt>[\x00-\x7F]</tt></td></tr>
    <tr><td><tt>\p{Alpha}</tt></td>
        <td>An alphabetic character:<tt>\p{IsAlphabetic}</tt></td></tr>
    <tr><td><tt>\p{Digit}</tt></td>
        <td>A decimal digit character:<tt>p{IsDigit}</tt></td></tr>
    <tr><td><tt>\p{Alnum}</tt></td>
        <td>An alphanumeric character:<tt>[\p{IsAlphabetic}\p{IsDigit}]</tt></td></tr>
    <tr><td><tt>\p{Punct}</tt></td>
        <td>A punctuation character:<tt>p{IsPunctuation}</tt></td></tr>
    <tr><td><tt>\p{Graph}</tt></td>
        <td>A visible character: <tt>[^\p{IsWhite_Space}\p{gc=Cc}\p{gc=Cs}\p{gc=Cn}]</tt></td></tr>
    <tr><td><tt>\p{Print}</tt></td>
        <td>A printable character: <code>[\p{Graph}\p{Blank}&amp;&amp;[^\p{Cntrl}]]</code></td></tr>
    <tr><td><tt>\p{Blank}</tt></td>
        <td>A space or a tab: <code>[\p{IsWhite_Space}&amp;&amp;[^\p{gc=Zl}\p{gc=Zp}\x0a\x0b\x0c\x0d\x85]]</code></td></tr>
    <tr><td><tt>\p{Cntrl}</tt></td>
        <td>A control character: <tt>\p{gc=Cc}</tt></td></tr>
    <tr><td><tt>\p{XDigit}</tt></td>
        <td>A hexadecimal digit: <tt>[\p{gc=Nd}\p{IsHex_Digit}]</tt></td></tr>
    <tr><td><tt>\p{Space}</tt></td>
        <td>A whitespace character:<tt>\p{IsWhite_Space}</tt></td></tr>
    <tr><td><tt>\d</tt></td>
        <td>A digit: <tt>\p{IsDigit}</tt></td></tr>
    <tr><td><tt>\D</tt></td>
        <td>A non-digit: <tt>[^\d]</tt></td></tr>
    <tr><td><tt>\s</tt></td>
        <td>A whitespace character: <tt>\p{IsWhite_Space}</tt></td></tr>
    <tr><td><tt>\S</tt></td>
        <td>A non-whitespace character: <tt>[^\s]</tt></td></tr>
    <tr><td><tt>\w</tt></td>
        <td>A word character: <tt>[\p{Alpha}\p{gc=Mn}\p{gc=Me}\p{gc=Mc}\p{Digit}\p{gc=Pc}\p{IsJoin_Control}]</tt></td></tr>
    <tr><td><tt>\W</tt></td>
        <td>A non-word character: <tt>[^\w]</tt></td></tr>
</table>
</div>

<div></div>
<div></div>

</body>
</html>
